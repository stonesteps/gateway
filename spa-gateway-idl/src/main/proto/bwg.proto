option optimize_for = LITE_RUNTIME;

option java_package = "com.tritonsvc.spa.communication.proto";

//////////////////////////////////////////////////////////////////////////////////
// IDL for Uplink and Downlink messages between the Spa System and the Cloud
//
// Serialized format is:
// Header + UplinkHeader + Uplink Model Message
//     or
// Header + DownlinkHeader + Downlink Modle Message
//
//////////////////////////////////////////////////////////////////////////////////

enum CommandType {
	UPLINK = 1;
	DOWNLINK = 2;
}

enum AckResponseCode {
    OK = 1;
    ERROR = 2;
    NOT_REGISTERED = 3;
    RECEIVED = 4;
}

/////////////////////////////////////////////////////////////////////////
// Header contains the command type which specifies direction.
// originator is a guid that represents an original message instance that ensuing messages
// are considered to be associated with, such as responses for prior requests.
// In many cases a single request may spawn multiple asynch response messages, each can specify the
// the same originator to tie back to original request.
/////////////////////////////////////////////////////////////////////////
message Header {
	required CommandType command = 1;
    optional string originator = 2;
    required uint64 sentTimestamp = 3;
}

/////////////////////////////////////////////////////////////////////////
// A single piece of metadata, general definition of a key pair that is used in
// in many message defs
/////////////////////////////////////////////////////////////////////////
message Metadata {
    required string name = 1;
    required string value = 2;
}

//////////////////////////////////////////////////////////////////////////
// Uplink Messages - sent from spa gateway to the cloud, actual sender aka 'originator' could be
//                   any component in the spa system, i.e. the gateway or the controller or a mote even
//////////////////////////////////////////////////////////////////////////
message Uplink {

	enum UplinkCommandType {
		REGISTRATION = 1;
		ACKNOWLEDGEMENT = 2;
		SPA_STATE = 3;
        EVENT = 4;
        MEASUREMENT = 5;
	}

    message UplinkHeader {
        required UplinkCommandType command = 1;
        optional string hardwareId = 2; // most messages specify this, RegisterDevice does not
    }

    message Model {

        // Register a device with Cloud.
        message RegisterDevice {
            required string deviceTypeName = 1;
            optional string parentDeviceHardwareId = 2; // this could be blank if it's the gateway
                                                        // or if its any device under the gateway, this id should be
                                                        // the registered id
            repeated Metadata metadata = 3; // this can be a key/value of whatever attributes a device can provide
                                            // unique identification, would be serial number for gateway, may be mac address
                                            // for others
        }

        message DownlinkAcknowledge {
            required AckResponseCode code = 1;
            optional string description = 2;
        }

        // Report device alert.
        message Notification {
            required string alertType = 1;
            required string alertMessage = 2;
            optional fixed64 eventDate = 3;
            repeated Metadata metadata = 4;
        }

        // A single measurement.
        message Measurement {
            required string measurementId = 1;
            required double measurementValue = 2;
        }

        // Event message for device measurements.
        message DeviceMeasurements {
            repeated Measurement measurement = 1;
            optional fixed64 eventDate = 2;
            repeated Metadata metadata = 3;
        }

        // check for existence, some of these child components may be absent initially, Controller at a minimum
        // will be here, but left as optional for processing ease in the agent.
        //
        // Some attributes have enums associated to them, however they are not typed by that enum
        // that's because not all values have enum values assigned, this would cause potential runtime errors during ser/deser
        message SpaState {
            optional Controller controller = 1;
            optional SetupParams setupParams = 2;
            optional SystemInfo systemInfo = 3;
            optional Components components = 4;
            required fixed64 lastUpdateTimestamp = 5;
        }

        // this is the state of each known component attached to controller
        // if a component doesn't exist on spa, then it will be absent here. use hasXX() methods first to check
        // if a component supports requests, the number of requestable states it will support is carried in AvailableStates
        // or if the datatype of component is bool that means the component only supports binary ON/OFF state
        message Components {
            // the heater state is read-only, there is no command to change it's state
            optional Constants.HeaterState heater1= 1;
            optional Constants.HeaterState heater2= 2;
            // ON/OFF components
            optional bool ozone = 3;
            optional bool microSilk = 4;
            optional bool aux1 = 5;
            optional bool aux2 = 6;
            optional bool aux3 = 7;
            optional bool aux4 = 8;
            optional bool mister1 = 9;
            optional bool mister2 = 10;
            optional bool mister3 = 11;
            // Multi-state components
            optional PumpComponent pump1 =12;
            optional PumpComponent pump2 =13;
            optional PumpComponent pump3 =14;
            optional PumpComponent pump4 =15;
            optional PumpComponent pump5 =16;
            optional PumpComponent pump6 =17;
            optional PumpComponent pump7 =18;
            optional PumpComponent pump8 =19;
            optional PumpComponent circulationPump = 28;
            optional BlowerComponent blower1 = 21;
            optional BlowerComponent blower2 = 22;
            optional LightComponent light1 = 23;
            optional LightComponent light2 = 24;
            optional LightComponent light3 = 25;
            optional LightComponent light4 = 26;
            // not sure about fiber wheel, leaving in here, but wouldn't refer to it in upper levels yet
            optional uint32 fiberWheel = 20;
            required fixed64 lastUpdateTimestamp = 27;

            message PumpComponent {
                optional Constants.TriState currentState = 1;
                required Constants.AvailableStates availableStates = 2;
            }

            message BlowerComponent {
                optional Constants.QuadState currentState = 1;
                required Constants.AvailableStates availableStates = 2;
            }

            message LightComponent {
                optional Constants.QuadState currentState = 1;
                required Constants.AvailableStates availableStates = 2;
            }
        }

        // this is the state of spa as obtained from the PanelUpdate message
        message Controller {
            // HeaterMode enum applies here, this is called Run Mode in ICD, but it's really the heater
            required uint32 heaterMode = 1;
            // this is always in Fahrenheit
            required uint32 currentWaterTemp = 2;
            required uint32 hour = 3;
            required uint32 minute = 4;
            required fixed64 lastUpdateTimestamp = 5;
            required uint32 errorCode = 6;
            // PanelDisplayCode enum applies here
            required uint32 uiCode = 7;
            required uint32 uiSubCode = 8;
            required bool invert = 9;
            required bool allSegsOn = 10;
            required bool panelLock = 11;
            required bool filter1 = 12;
            required bool filter2 = 13;
            required bool military = 14;
            required bool celsius = 15;
            required Constants.TempRange tempRange =16;
            required bool primingMode =17;
            required bool soundAlarm = 18;
            required bool repeat = 19;
            required Constants.PanelMode panelMode = 21;
            required Constants.SwimSpaMode swimSpaMode = 22;
            // MessageSeverity enum applies here
            required uint32 messageSeverity = 23;
            required bool swimSpaModeChanging = 24;
            required bool heaterCooling = 25;
            required bool latchingMessage = 26;
            required bool demoMode = 27;
            required bool cleanupCycle = 28;
            required bool timeNotSet = 29;
            required bool lightCycle = 30;
            // this is always in Fahrenheit
            required uint32 targetWaterTemperature = 31;
            required bool elapsedTimeDisplay = 32;
            required uint32 tvLiftState = 33;
            required bool settingsLock = 34;
            required bool spaOverheatDisabled = 35;
            required bool specialTimeouts = 36;
            required bool ABDisplay = 37;
            required bool stirring = 38;
            required bool ecoMode = 39;
            required bool soakMode = 40;
            // BluetoothStatus enum applies here
            required uint32 bluetoothStatus = 41;
            required bool overrangeEnabled = 42;
            required bool heatExternallyDisabled = 43;
            required bool testMode = 44;
            required bool tempLock = 45;
        }

        // This is the parameters that spa has been programmed with
        message SetupParams {
            required int32 lowRangeLow = 1;
            required int32 lowRangeHigh = 2;
            required int32 highRangeLow = 3;
            required int32 highRangeHigh = 4;
            required bool gfciEnabled = 5;
            required bool drainModeEnabled = 6;
            required fixed64 lastUpdateTimestamp = 7;
        }

        // This is the 'About' for spa, has sw versions, etc
        message SystemInfo {
            // HeaterPower enum applies here
            required int32 heaterPower = 1;
            required uint32 mfrSSID = 2;
            required uint32 modelSSID = 3;
            required uint32 versionSSID = 4;
            required uint32 minorVersion = 5;
            required uint32 swSignature = 6;
            required uint32 heaterType = 7;
            required uint32 currentSetup = 8;
            required fixed64 lastUpdateTimestamp = 9;
        }

        message Constants {

            enum AvailableStates {
                UNARY = 1;
                BINARY = 2;
                TRIPLE = 3;
                QUAD = 4;
            }

            enum HeaterPower {
                VOLT_120 = 0;
                VOLT_240 = 1;
                ONETOTHREE_KW = 2;
                THREETOSIX_KW = 3;
            }

            enum BluetoothStatus {
                NOT_PRESENT = 0;
                OFF = 1;
                POWERING_UP = 2;
                DISCOVERABLE = 3;
                CONNECTED = 4;
                LINEIN_MODE = 5;
                MODE_CHANGING = 6;
                POWERING_DOWN = 7;
                IDLE = 8;
                AMPLIFIER_COMMS_LOST = 15;
            }

            enum PanelDisplayCode {
                STANDBY = 5;
                DEMO = 0xF;
            }

            enum HeaterMode {
                REST = 1;
                READY = 2;
            }

            enum EventType {
                NOTIFY = 1;
                ALERT = 2;
            }

            enum HeaterState {
                HEATER_OFF = 0;
                HEATER_ON = 1;
                HEATER_WAITING = 2;
                HEATER_UNDEFINED = 3;
            }

            enum QuadState {
                QUAD_OFF = 0;
                QUAD_LOW = 1;
                QUAD_MED = 2;
                QUAD_HIGH = 3;
            }

            enum TriState {
                TRI_OFF = 0;
                TRI_LOW = 1;
                TRI_HIGH = 2;
            }

            enum TempRange {
                LOW = 0;
                HIGH = 1;
            }

            enum PanelMode {
                PANEL_MODE_NGSC = 0;
                PANEL_MODE_SWIM_SPA = 1;
                PANEL_MODE_UNDEFINED_0 = 2;
                PANEL_MODE_UNDEFINED_1 = 3;
            }

            enum SwimSpaMode {
                SWIM_MODE_OTHER = 0;
                SWIM_MODE_SPA = 1;
                SWIM_MODE_SWIM = 2;
                SWIM_MODE_SPILLOVER = 3;
            }

            enum MessageSeverity {
                NONE = 0;
                REMINDER = 1;
                INFO = 2;
                WARNING = 3;
                ERROR = 4;
                FATAL = 5;
            }

            enum ComponentType {
                HEATER = 0;
                OZONE = 1;
                MICROSILK = 2;
                AUX = 3;
                MISTER = 4;
                PUMP = 5;
                FIBERWHEEL = 6;
                BLOWER = 7;
                LIGHT = 8;
                AV = 9;
            }
        }

        // A non-scheduled event
        message Event {
            required Constants.EventType eventType = 1;
            optional fixed64 eventTimestamp = 2;
            repeated Metadata metadata = 3;
        }
    }
}

/////////////////////////////////////////////////////////////////////
// Downlink Messages - sent from cloud to the spa gateway, final destination can be any component within the spa system.
//                     the gateway is always the proxy
/////////////////////////////////////////////////////////////////////
message Downlink {

	enum DownlinkCommandType {
        ACK = 1;
        REGISTRATION_RESPONSE = 2;
        SPA_REGISTRATION_RESPONSE =3;
        REQUEST = 4;
	}

	// Header contains the command and originator.
	message DownlinkHeader {
		required DownlinkCommandType commandType = 1;
        required string hardwareId = 2; // this could be hardware id for a nested component or in  most case the gw
                                        // the id will be the mongodb generated id for the device
    }

    message Model {

        // Acknowledge previous uplink command.
        message UplinkAcknowledge {
            required AckResponseCode code = 1;
            optional string description = 2;
        }

        // Enumeration of registation state responses.
        enum RegistrationAckState {NEW_REGISTRATION = 1; ALREADY_REGISTERED = 2; REGISTRATION_ERROR = 3;}
        enum RegistrationAckError {INVALID_DEVICE_ID = 1; NEW_DEVICES_NOT_ALLOWED = 2;}

        // Acknowledges prior registration uplink, the hardwareId returned in header will be
        // the generated id field in the mongodb that was created in the cloud when registration message was received
        message RegistrationResponse {
            required RegistrationAckState state = 1;
            optional RegistrationAckError errorType = 2;
            optional string errorMessage = 3;
        }

        message SpaRegistrationResponse {
            required RegistrationAckState state = 1;
            optional RegistrationAckError errorType = 2;
            optional string errorMessage = 3;
            required string p2pAPSSID = 4;
            required string p2pAPPassword = 5;
        }

        enum RequestType {
            PUMPS = 1;
            LIGHTS = 2;
            BLOWER = 3;
            MISTER = 4;
            FILTER = 5;
            DIAG_REPORT = 6;
            PANEL = 7; // LOCK or UNLOCK
            HEATER = 8;
            OZONE = 9;
            MICROSILK = 10;
            AUX = 11;
        }

        enum SpaCommandAttribName {
            DESIREDTEMP = 1;
            DESIREDSTATE = 2;
            PORT = 3;
        }

        message RequestMetadata {
            required SpaCommandAttribName name = 1;
            required string value = 2;
        }

        // each request has a type, then any parameters specific to
        // request type are carried in the metadata as key/value pairs
        // one common attribute will probably be 'port' as in 1, 2, 3 because there
        // multiple ports on the controller for each of these types such as pumps1, pumps2, filter1, fitler2, etc
        message Request {
            required RequestType requestType = 1;
            repeated RequestMetadata metadata = 2;
        }
    }
}