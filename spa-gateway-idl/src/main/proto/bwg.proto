option optimize_for = LITE_RUNTIME;

option java_package = "com.tritonsvc.spa.communication.proto";

//////////////////////////////////////////////////////////////////////////////////
// IDL for Uplink and Downlink messages between the Spa System and the Cloud
//
// Serialized format is:
// Header + UplinkHeader + Uplink Model Message
//     or
// Header + DownlinkHeader + Downlink Modle Message
//
//////////////////////////////////////////////////////////////////////////////////

enum CommandType {
	UPLINK = 1;
	DOWNLINK = 2;
}

enum AckResponseCode {
    OK = 1;
    ERROR = 2;
}

enum SpaCommandAttribName {
    DESIREDTEMP = 1;
    DESIREDSTATE = 2;
    PORT = 3;
}

/////////////////////////////////////////////////////////////////////////
// Header contains the command type which specifies direction.
// originator is a guid that represents an original message instance that ensuing messages
// are considered to be associated with, such as responses for prior requests.
// In many cases a single request may spawn multiple asynch response messages, each can specify the
// the same originator to tie back to original request.
/////////////////////////////////////////////////////////////////////////
message Header {
	required CommandType command = 1;
    optional string originator = 2;
    required uint64 sentTimestamp = 3;
}

/////////////////////////////////////////////////////////////////////////
// A single piece of metadata, general definition of a key pair that is used in
// in many message defs
/////////////////////////////////////////////////////////////////////////
message Metadata {
    required string name = 1;
    required string value = 2;
}

//////////////////////////////////////////////////////////////////////////
// Uplink Messages - sent from spa gateway to the cloud, actual sender aka 'originator' could be
//                   any component in the spa system, i.e. the gateway or the controller or a mote even
//////////////////////////////////////////////////////////////////////////
message Uplink {

	enum UplinkCommandType {
		REGISTRATION = 1;
		ACKNOWLEDGEMENT = 2;
		MEASUREMENT = 3;
        EVENT = 4;
	}

    message UplinkHeader {
        required UplinkCommandType command = 1;
        optional string hardwareId = 2; // most messages specify this, RegisterDevice does not
    }

    message Model {

        // Register a device with Cloud.
        message RegisterDevice {
            required string deviceTypeName = 1;
            optional string parentDeviceHardwareId = 2; // this could be blank if it's the gateway
                                                        // or if its any device under the gateway, this id should be
                                                        // the registered id
            repeated Metadata metadata = 3; // this can be a key/value of whatever attributes a device can provide
                                            // unique identification, would be serial number for gateway, may be mac address
                                            // for others
        }

        message DownlinkAcknowledge {
            required AckResponseCode code = 1;
            optional string description = 2;
        }

        // Report device alert.
        message Notification {
            required string alertType = 1;
            required string alertMessage = 2;
            optional fixed64 eventDate = 3;
            repeated Metadata metadata = 4;
        }

        // A single measurement.
        message Measurement {
            required string measurementId = 1;
            required double measurementValue = 2;
        }

        // Event message for device measurements.
        message DeviceMeasurements {
            repeated Measurement measurement = 1;
            optional fixed64 eventDate = 2;
            repeated Metadata metadata = 3;
        }

        enum EventType {
            NOTIFY = 1;
            ALERT = 2;
        }

        // A non-scheduled event
        message Event {
            required EventType eventType = 1;
            optional fixed64 eventTimestamp = 2;
            repeated Metadata metadata = 3;
        }
    }
}

/////////////////////////////////////////////////////////////////////
// Downlink Messages - sent from cloud to the spa gateway, final destination can be any component within the spa system.
//                     the gateway is always the proxy
/////////////////////////////////////////////////////////////////////
message Downlink {

	enum DownlinkCommandType {
        ACK = 1;
        REGISTRATION_RESPONSE = 2;
        REQUEST = 3;
	}

	// Header contains the command and originator.
	message DownlinkHeader {
		required DownlinkCommandType commandType = 1;
        required string hardwareId = 2; // this could be hardware id for a nested component or in  most case the gw
                                        // the id will be the mongodb generated id for the device
    }

    message Model {

        // Acknowledge previous uplink command.
        message UplinkAcknowledge {
            required AckResponseCode code = 1;
            optional string description = 2;
        }

        // Enumeration of registation state responses.
        enum RegistrationAckState {NEW_REGISTRATION = 1; ALREADY_REGISTERED = 2; REGISTRATION_ERROR = 3;}
        enum RegistrationAckError {INVALID_DEVICE_ID = 1; NEW_DEVICES_NOT_ALLOWED = 2;}

        // Acknowledges prior registration uplink, the hardwareId returned in header will be
        // the generated id field in the mongodb that was created in the cloud when registration message was received
        message RegistrationResponse {
            required RegistrationAckState state = 1;
            optional RegistrationAckError errorType = 2;
            optional string errorMessage = 3;
            required string p2pAPSSID = 4;
            required string p2pAPPassword = 5;
        }

        enum RequestType {
            PUMPS = 1;
            LIGHTS = 2;
            BLOWER = 3;
            MISTER = 4;
            FILTER = 5;
            DIAG_REPORT = 6;
            PANEL = 7; // LOCK or UNLOCK
            HEATER = 8;
        }

        // each request has a type, then any parameters specific to
        // request type are carried in the metadata as key/value pairs
        // one common attribute will probably be 'port' as in 1, 2, 3 because there
        // multiple ports on the controller for each of these types such as pumps1, pumps2, filter1, fitler2, etc
        message Request {
            required RequestType requestType = 1;
            repeated Metadata metadata = 2;
        }
    }
}